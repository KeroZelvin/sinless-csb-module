{
  "name": "Sinless Pool Roll",
  "type": "script",
  "author": "KoiB8oaGNkPdgzdM",
  "img": "icons/svg/dice-target.svg",
  "scope": "global",
  "command": "/**\n * Sinless Pool Roller (Foundry v13) — TN from \"Session Settings\" actor\n * - One dialog table for Brawn/Finesse/Resolve/Focus\n * - Enter Spend + Mod for each row\n * - Click Roll to roll Total d6, count successes >= TN_Global from Session Settings\n * - Spend depletes the pool (Mod does not)\n * - Adds \"Refresh Pools\" button (top-right) that recalculates pools per PDF:\n *   Brawn   = STR + floor(BOD/2) + floor(WIL/4)\n *   Finesse = REA + floor(BOD/2) + floor(INT/4)\n *   Resolve = WIL + floor(INT/2) + floor(CHA/2)\n *   Focus   = INT + floor(REA/2) + floor(WIL/4)\n *   Plus: add floor(CHA/4) to exactly one pool based on chaQuarterPoolN (1..4).\n */\n\nfunction findKeyPath(obj, targetKey, basePath = \"system\") {\n  const stack = [{ value: obj, path: basePath }];\n  const seen = new Set();\n  while (stack.length) {\n    const { value, path } = stack.pop();\n    if (!value || typeof value !== \"object\") continue;\n    if (seen.has(value)) continue;\n    seen.add(value);\n\n    if (Object.prototype.hasOwnProperty.call(value, targetKey)) return `${path}.${targetKey}`;\n    for (const [k, v] of Object.entries(value)) {\n      if (v && typeof v === \"object\") stack.push({ value: v, path: `${path}.${k}` });\n    }\n  }\n  return null;\n}\n\nfunction getByPath(root, path) {\n  return path.split(\".\").reduce((o, k) => (o ? o[k] : undefined), root);\n}\n\nfunction num(x, fallback = 0) {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : fallback;\n}\n\nfunction clampTN(tn, fallback = 4) {\n  return [4, 5, 6].includes(tn) ? tn : fallback;\n}\n\nfunction getSessionSettingsActor() {\n  const a = game.actors?.getName?.(\"Session Settings\");\n  if (a) return a;\n  const lower = \"session settings\";\n  return (game.actors?.contents ?? []).find(x => (x.name ?? \"\").trim().toLowerCase() === lower) ?? null;\n}\n\nasync function main() {\n  const actor = canvas.tokens.controlled[0]?.actor ?? game.user.character;\n  if (!actor) {\n    ui.notifications.warn(\"Select a token or set a User Character.\");\n    return;\n  }\n\n  const sessionActor = getSessionSettingsActor();\n  if (!sessionActor) {\n    ui.notifications.error('Actor \"Session Settings\" not found. Create an Actor with that exact name.');\n    return;\n  }\n\n  // TN_Global from Session Settings actor\n  const tnPath = findKeyPath(sessionActor.system, \"TN_Global\", \"system\");\n  let tn = clampTN(tnPath ? num(getByPath(sessionActor, tnPath), 4) : 4, 4);\n\n  const pools = [\n    { name: \"Brawn\",  key: \"Brawn_Cur\" },\n    { name: \"Finesse\", key: \"Finesse_Cur\" },\n    { name: \"Resolve\", key: \"Resolve_Cur\" },\n    { name: \"Focus\",  key: \"Focus_Cur\" }\n  ];\n\n  for (const p of pools) p.path = findKeyPath(actor.system, p.key, \"system\");\n\n  const missingPools = pools.filter(p => !p.path).map(p => p.key);\n  if (missingPools.length) {\n    ui.notifications.error(`Missing pool field(s) on actor: ${missingPools.join(\", \")}`);\n    return;\n  }\n\n  // Attribute keys used for refresh (must match your CSB field keys)\n  const attrKeys = [\"STR\", \"BOD\", \"WIL\", \"REA\", \"INT\", \"CHA\", \"chaQuarterPoolN\"];\n  const attrPaths = {};\n  for (const k of attrKeys) attrPaths[k] = findKeyPath(actor.system, k, \"system\");\n\n  const missingAttrs = attrKeys.filter(k => !attrPaths[k]);\n  const refreshDisabled = missingAttrs.length > 0;\n\n  function readAttr(k) {\n    const p = attrPaths[k];\n    return p ? num(getByPath(actor, p), 0) : 0;\n  }\n\n  function floorDiv(a, d) {\n    return Math.floor(num(a, 0) / d);\n  }\n\n  async function readTNFromSession($html) {\n    const raw = tnPath ? num(getByPath(sessionActor, tnPath), 4) : 4;\n    tn = clampTN(raw, 4);\n    if ($html) $html.find(\"span.tn\").text(String(tn));\n    return tn;\n  }\n\n  async function refreshPoolsAndUI($html) {\n    if (refreshDisabled) return;\n\n    // Read attributes fresh\n    const STR = readAttr(\"STR\");\n    const BOD = readAttr(\"BOD\");\n    const WIL = readAttr(\"WIL\");\n    const REA = readAttr(\"REA\");\n    const INT = readAttr(\"INT\");\n    const CHA = readAttr(\"CHA\");\n    const qN  = readAttr(\"chaQuarterPoolN\");\n\nconst chaQ = Math.floor(CHA / 4);  // floor(CHA/4)\n\n// Text-spec formulas, independent floor:\nconst brawn =\n  STR + Math.floor(BOD / 2) + Math.floor(WIL / 4) + (qN === 1 ? chaQ : 0);\n\nconst finesse =\n  REA + Math.floor(BOD / 2) + Math.floor(INT / 4) + (qN === 2 ? chaQ : 0);\n\nconst resolve =\n  WIL + Math.floor(INT / 2) + Math.floor(CHA / 2) + (qN === 3 ? chaQ : 0);\n\nconst focus =\n  INT + Math.floor(REA / 2) + Math.floor(WIL / 4) + (qN === 4 ? chaQ : 0);\n\n\n    const updates = {\n      [pools.find(p => p.key === \"Brawn_Cur\").path]: brawn,\n      [pools.find(p => p.key === \"Finesse_Cur\").path]: finesse,\n      [pools.find(p => p.key === \"Resolve_Cur\").path]: resolve,\n      [pools.find(p => p.key === \"Focus_Cur\").path]: focus\n    };\n\n    await actor.update(updates);\n\n    // Update dialog Current column\n    $html.find(`span.cur[data-cur=\"Brawn_Cur\"]`).text(String(brawn));\n    $html.find(`span.cur[data-cur=\"Finesse_Cur\"]`).text(String(finesse));\n    $html.find(`span.cur[data-cur=\"Resolve_Cur\"]`).text(String(resolve));\n    $html.find(`span.cur[data-cur=\"Focus_Cur\"]`).text(String(focus));\n\n    ui.notifications.info(\"Pools refreshed.\");\n  }\n\n  // Initial current values\n  const cur = {};\n  for (const p of pools) cur[p.key] = num(getByPath(actor, p.path), 0);\n\n  const content = `\n  <form>\n    <div style=\"display:flex; align-items:center; justify-content:space-between; gap: 12px; margin-bottom: 0.5rem;\">\n      <div>\n        <strong>Target Number (Session Settings):</strong> <span class=\"tn\">${tn}</span>+\n      </div>\n      <div>\n        <button type=\"button\" class=\"refresh\" ${refreshDisabled ? \"disabled\" : \"\"}>\n          Refresh Pools\n        </button>\n      </div>\n    </div>\n\n    <table style=\"width:100%; border-collapse: collapse;\">\n      <thead>\n        <tr>\n          <th style=\"text-align:left; padding: 4px 6px;\">Pool</th>\n          <th style=\"text-align:right; padding: 4px 6px;\">Current</th>\n          <th style=\"text-align:right; padding: 4px 6px;\">Spend</th>\n          <th style=\"text-align:right; padding: 4px 6px;\">Mod</th>\n          <th style=\"text-align:left; padding: 4px 6px;\">Action</th>\n        </tr>\n      </thead>\n      <tbody>\n        ${pools.map(p => `\n          <tr data-pool=\"${p.key}\">\n            <td style=\"padding: 4px 6px;\"><strong>${p.name}</strong></td>\n            <td style=\"padding: 4px 6px; text-align:right;\">\n              <span class=\"cur\" data-cur=\"${p.key}\">${cur[p.key]}</span>\n            </td>\n            <td style=\"padding: 4px 6px; text-align:right;\">\n              <input type=\"number\" name=\"${p.key}_spend\" value=\"0\" min=\"0\" step=\"1\" style=\"width: 6em; text-align:right;\" />\n            </td>\n            <td style=\"padding: 4px 6px; text-align:right;\">\n              <input type=\"number\" name=\"${p.key}_mod\" value=\"0\" step=\"1\" style=\"width: 6em; text-align:right;\" />\n            </td>\n            <td style=\"padding: 4px 6px;\">\n              <button type=\"button\" class=\"roll\" data-pool=\"${p.key}\">Roll</button>\n              <button type=\"button\" class=\"clear\" data-pool=\"${p.key}\" style=\"margin-left:6px;\">Clear</button>\n            </td>\n          </tr>\n        `).join(\"\")}\n      </tbody>\n    </table>\n\n    <p style=\"margin-top: 0.75rem; opacity: 0.85;\">\n      Spend depletes the pool; Mod adds/removes dice but does not deplete.\n      ${refreshDisabled ? `<br><em>Refresh disabled: missing attribute key(s): ${missingAttrs.join(\", \")}</em>` : \"\"}\n    </p>\n  </form>\n  `;\n\n  const dialog = new Dialog({\n    title: `Sinless Pools — ${actor.name}`,\n    content,\n    buttons: { close: { label: \"Close\" } },\n    default: \"close\",\n    render: (html) => {\n      const $html = html;\n\n      function getPoolDef(poolKey) {\n        return pools.find(p => p.key === poolKey);\n      }\n\n      async function doRoll(poolKey) {\n        // refresh TN each roll (GM may change mid-session)\n        await readTNFromSession($html);\n\n        const p = getPoolDef(poolKey);\n        if (!p) return;\n\n        const curVal = num(getByPath(actor, p.path), 0);\n        const spend = num($html.find(`[name=\"${poolKey}_spend\"]`).val(), 0);\n        const mod = num($html.find(`[name=\"${poolKey}_mod\"]`).val(), 0);\n\n        const spendClamped = Math.max(0, Math.min(curVal, spend));\n        const totalDice = Math.max(0, spendClamped + mod);\n\n        const roll = await (new Roll(`${totalDice}d6`)).evaluate({ async: true });\n        const results = roll.dice?.[0]?.results ?? [];\n        const successes = results.reduce((acc, r) => acc + (r.result >= tn ? 1 : 0), 0);\n\n        const newCur = Math.max(0, curVal - spendClamped);\n        await actor.update({ [p.path]: newCur });\n\n        $html.find(`span.cur[data-cur=\"${poolKey}\"]`).text(String(newCur));\n        $html.find(`[name=\"${poolKey}_spend\"]`).val(0);\n        $html.find(`[name=\"${poolKey}_mod\"]`).val(0);\n\n        const flavor = `\n          <div>\n            <h2>${p.name} Test</h2>\n            <p><strong>Actor:</strong> ${actor.name}</p>\n            <p><strong>TN (Session Settings):</strong> ${tn}+</p>\n            <p><strong>Spend:</strong> ${spendClamped} (depletes) &nbsp; | &nbsp;\n               <strong>Mod:</strong> ${mod} (free) &nbsp; | &nbsp;\n               <strong>Total:</strong> ${totalDice}d6</p>\n            <p><strong>Successes:</strong> ${successes}</p>\n            <p><strong>${p.name}:</strong> ${curVal} → ${newCur}</p>\n          </div>\n        `;\n\n        await roll.toMessage(\n          { speaker: ChatMessage.getSpeaker({ actor }), flavor },\n          { create: true }\n        );\n      }\n\n      $html.find(\"button.refresh\").on(\"click\", async (ev) => {\n        ev.preventDefault();\n        try {\n          await refreshPoolsAndUI($html);\n        } catch (e) {\n          console.error(e);\n          ui.notifications.error(\"Refresh Pools failed. See console (F12).\");\n        }\n      });\n\n      $html.find(\"button.roll\").on(\"click\", async (ev) => {\n        ev.preventDefault();\n        const poolKey = ev.currentTarget.dataset.pool;\n        try {\n          await doRoll(poolKey);\n        } catch (e) {\n          console.error(e);\n          ui.notifications.error(`Roll failed for ${poolKey}. See console (F12).`);\n        }\n      });\n\n      $html.find(\"button.clear\").on(\"click\", (ev) => {\n        ev.preventDefault();\n        const poolKey = ev.currentTarget.dataset.pool;\n        $html.find(`[name=\"${poolKey}_spend\"]`).val(0);\n        $html.find(`[name=\"${poolKey}_mod\"]`).val(0);\n      });\n    }\n  });\n\n  dialog.render(true);\n}\n\nmain();",
  "folder": null,
  "flags": {},
  "_stats": {
    "compendiumSource": null,
    "duplicateSource": null,
    "exportSource": {
      "worldId": "sinless",
      "uuid": "Macro.KS48C1t3MOQg7QmC",
      "coreVersion": "13.351",
      "systemId": "custom-system-builder",
      "systemVersion": "5.0.2"
    },
    "coreVersion": "13.351",
    "systemId": "custom-system-builder",
    "systemVersion": "5.0.2",
    "createdTime": 1767304088923,
    "modifiedTime": 1767458773427,
    "lastModifiedBy": "KoiB8oaGNkPdgzdM"
  },
  "ownership": {
    "default": 0
  }
}