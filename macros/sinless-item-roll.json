{
  "name": "Sinless Item Roll",
  "type": "script",
  "author": "KoiB8oaGNkPdgzdM",
  "img": "icons/svg/dice-target.svg",
  "scope": "global",
  "command": "/**\n * Sinless Item Roll (Foundry v13) — CSB-compatible (v5.4.8)\n *\n * Adds:\n * - Skill groups defaulting: if target skill is untrained (0) but in a group, auto-pick highest trained group skill and apply -2 dice (affects spend limit)\n * - Untrained fallback (non-asterisk skills only): if no ranks in the skill or any group skill, roll ALL dice in linked pool; every 4 successes = 1 success\n * - SkillMeta_JSON support: reads JSON from \"Session Settings\" actor text field SkillMeta_JSON (optional but recommended)\n *\n * Still supports:\n * - Manual run (no args): requires selected token or user character, and requires itemUuid or itemId+actorUuid (no item picker; provide via buttons)\n * - Macro.execute({ itemUuid }) or Macro.execute({ actorUuid, itemId })\n */\n\nfunction findKeyPath(obj, targetKey, basePath = \"system\") {\n  const stack = [{ value: obj, path: basePath }];\n  const seen = new Set();\n  while (stack.length) {\n    const { value, path } = stack.pop();\n    if (!value || typeof value !== \"object\") continue;\n    if (seen.has(value)) continue;\n    seen.add(value);\n\n    if (Object.prototype.hasOwnProperty.call(value, targetKey)) return `${path}.${targetKey}`;\n    for (const [k, v] of Object.entries(value)) {\n      if (v && typeof v === \"object\") stack.push({ value: v, path: `${path}.${k}` });\n    }\n  }\n  return null;\n}\n\nfunction getByPath(root, path) {\n  return path.split(\".\").reduce((o, k) => (o ? o[k] : undefined), root);\n}\n\nfunction num(x, fallback = 0) {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : fallback;\n}\n\nfunction clampTN(tn, fallback = 4) {\n  return [4, 5, 6].includes(tn) ? tn : fallback;\n}\n\nfunction getSessionSettingsActor() {\n  const exact = game.actors?.getName?.(\"Session Settings\");\n  if (exact) return exact;\n  const lower = \"session settings\";\n  return (game.actors?.contents ?? []).find(a => (a.name ?? \"\").trim().toLowerCase() === lower) ?? null;\n}\n\nfunction normalizePoolKey(poolKeyRaw) {\n  if (!poolKeyRaw) return null;\n  const s = String(poolKeyRaw).trim();\n  if (!s) return null;\n\n  // Map logical pool names to your actor current keys\n  const map = {\n    Brawn: \"Brawn_Cur\",\n    Finesse: \"Finesse_Cur\",\n    Resolve: \"Resolve_Cur\",\n    Focus: \"Focus_Cur\"\n  };\n  return map[s] ?? s;\n}\n\nfunction readItemField(item, fieldName) {\n  const path = findKeyPath(item.system, fieldName, \"system\");\n  return path ? getByPath(item, path) : undefined;\n\n\n}\n\nfunction readActorProp(actor, key) {\n  // In CSB, actual values live under system.props. Avoid scanning actor.system broadly,\n  // because template metadata may also contain keys with default values.\n  const props = actor?.system?.props;\n  if (props && Object.prototype.hasOwnProperty.call(props, key)) return props[key];\n  // Fallback: search within props in case of nesting (rare), but never outside props.\n  if (props && typeof props === \"object\") {\n    const p = findKeyPath(props, key, \"system.props\");\n    return p ? getByPath(actor, p) : undefined;\n  }\n  return undefined;\n}\n\nfunction safeParseJSON(maybeJSON, fallback) {\n  if (maybeJSON == null) return fallback;\n  if (typeof maybeJSON === \"object\") return maybeJSON; // already parsed\n  if (typeof maybeJSON !== \"string\") return fallback;\n  const s = maybeJSON.trim();\n  if (!s) return fallback;\n  try { return JSON.parse(s); } catch (_e) { return fallback; }\n}\n\nasync function getSkillMeta(sessionActor) {\n  // CSB stores most user-entered field values under system.props.\n  // Using findKeyPath can accidentally pick up template/metadata copies first,\n  // so prefer the live value in system.props when present.\n  // Preferred: store large JSON blobs in actor flags (always persisted regardless of CSB schema).\n  // To set: Session Settings actor -> setFlag(\"world\",\"SkillMeta_JSON\", \"<json>\")\n  let rawFlag = null;\n  try {\n    rawFlag = await sessionActor?.getFlag?.(\"world\", \"SkillMeta_JSON\");\n  } catch (_e) {\n    rawFlag = null;\n  }\n  const rawDirect = sessionActor?.system?.props?.SkillMeta_JSON;\n  const raw = (rawFlag !== undefined && rawFlag !== null && String(rawFlag).trim() !== \"\")\n    ? rawFlag\n    : (rawDirect !== undefined && rawDirect !== null && String(rawDirect).trim() !== \"\")\n      ? rawDirect\n      : (() => {\n          const path = findKeyPath(sessionActor.system, \"SkillMeta_JSON\", \"system\");\n          return path ? getByPath(sessionActor, path) : null;\n        })();\n\n  const meta = safeParseJSON(raw, null);\n  return (meta && typeof meta === \"object\") ? meta : null;\n}\n\nfunction resolveSkillInfo(skillMeta, skillKey) {\n  // skillMeta is expected to have a \"skills\" object keyed by Skill_*\n  if (!skillMeta || !skillMeta.skills || typeof skillMeta.skills !== \"object\") return null;\n  return skillMeta.skills[String(skillKey)] ?? null;\n}\n\nfunction getGroupSkillKeys(skillMeta, groupId) {\n  if (!skillMeta || !skillMeta.skills || typeof skillMeta.skills !== \"object\") return [];\n  const out = [];\n  for (const [k, v] of Object.entries(skillMeta.skills)) {\n    if (v && typeof v === \"object\" && v.groupId === groupId) out.push(k);\n  }\n  return out;\n}\n\nasync function promptRuntimeInputs({\n  title,\n  TN,\n  mode,\n  displayLines,\n  spendCap,\n  defaultSpend,\n  spendHelp,\n  allowSpend\n}) {\n  const header = (displayLines ?? []).map(l => `<div>${l}</div>`).join(\"\");\n\n  const spendBlock = allowSpend ? `\n    <div class=\"form-group\">\n      <label>Spend from Pool</label>\n      <div class=\"form-fields\" style=\"display:flex; gap:6px; align-items:center;\">\n        <button type=\"button\" class=\"sinless-step\" data-step=\"-1\" style=\"width:32px;\">-</button>\n        <input type=\"number\" name=\"spend\" value=\"${defaultSpend}\" min=\"0\" max=\"${spendCap}\" step=\"1\" style=\"flex:1;\"/>\n        <button type=\"button\" class=\"sinless-step\" data-step=\"1\" style=\"width:32px;\">+</button>\n      </div>\n      <p class=\"notes\" style=\"margin:6px 0 0 0;\">${spendHelp}</p>\n    </div>\n  ` : `\n    <div class=\"form-group\">\n      <label>Spend from Pool</label>\n      <p class=\"notes\" style=\"margin:6px 0 0 0;\">${spendHelp}</p>\n    </div>\n  `;\n\n  const content = `\n    <form>\n      <p style=\"margin:0 0 8px 0;\"><em>${header}</em></p>\n\n      <div class=\"form-group\">\n        <label>Situational Mod (± dice; non-pool)</label>\n        <input type=\"number\" name=\"sit\" value=\"0\" step=\"1\"/>\n      </div>\n\n      ${spendBlock}\n    </form>\n  `;\n\n  return await new Promise((resolve) => {\n    new Dialog({\n      title: title ?? \"Sinless Roll\",\n      content,\n      render: (html) => {\n        const input = html.find('input[name=\"spend\"]')[0];\n        html.find('button.sinless-step').on('click', (ev) => {\n          ev.preventDefault();\n          if (!input) return;\n          const step = Number(ev.currentTarget?.dataset?.step ?? 0);\n          const min = Number(input.min ?? 0);\n          const max = input.max !== \"\" ? Number(input.max) : Number.POSITIVE_INFINITY;\n          const cur = Number(input.value ?? 0);\n          let next = cur + step;\n          if (!Number.isFinite(next)) next = 0;\n          next = Math.max(min, Math.min(max, next));\n          input.value = String(next);\n          input.dispatchEvent(new Event('change'));\n        });\n      },\n      buttons: {\n        roll: {\n          label: \"Roll\",\n          callback: (html) => resolve({\n            sit: Number(html.find('[name=\"sit\"]').val()),\n            spend: allowSpend ? Number(html.find('[name=\"spend\"]').val()) : null\n          })\n        },\n        cancel: { label: \"Cancel\", callback: () => resolve(null) }\n      },\n      default: \"roll\"\n    }).render(true);\n  });\n}\n\n(async () => {\n  // Foundry v11+ passes Macro.execute({ ... }) arguments into a built-in `scope` object.\n  // Some modules (or older patterns) may instead provide `args` as an array. Support both.\n  const _scope =\n    (typeof scope !== \"undefined\" && scope && typeof scope === \"object\") ? scope :\n    (typeof args  !== \"undefined\" && Array.isArray(args) && args[0] && typeof args[0] === \"object\") ? args[0] :\n    {};\n\n  const _asCleanString = (v) => {\n    if (v === null || v === undefined) return null;\n    const s = String(v).trim();\n    if (!s || s === \"undefined\" || s === \"null\") return null;\n    return s;\n  };\n\n  const passedItemUuid  = _asCleanString(_scope.itemUuid);\n  const passedActorUuid = _asCleanString(_scope.actorUuid);\n  const passedItemId    = _asCleanString(_scope.itemId);\n\n  // Resolve actor\n  let actor = (passedActorUuid ? await fromUuid(passedActorUuid) : null) ?? canvas?.tokens?.controlled?.[0]?.actor ?? game.user.character ?? null;\n\n  // Resolve item\n  let item = null;\n\n  // If called from a CSB row/item-sheet button with actorUuid + itemId, resolve the embedded item directly\n  if (passedItemId) {\n    if (!actor) {\n      ui.notifications.warn(\"No actor found. Provide actorUuid, select a token, or set a User Character.\");\n      return;\n    }\n    item = actor.items?.get(passedItemId) ?? null;\n    if (!item) {\n      ui.notifications.error(\"Sinless Item Roll: passed itemId was not found on the resolved actor.\");\n      return;\n    }\n  }\n\n  // If called with itemUuid: resolve item by UUID and prefer embedded instance on its parent actor\n  if (!item && passedItemUuid) {\n    const doc = await fromUuid(passedItemUuid);\n    if (!doc || doc.documentName !== \"Item\") {\n      ui.notifications.error(\"Sinless Item Roll: itemUuid did not resolve to an Item.\");\n      return;\n    }\n\n    // Prefer embedded parent actor if present; otherwise fall back to selected token / user character\n    actor = (doc.parent?.documentName === \"Actor\") ? doc.parent : actor;\n    if (!actor) {\n      ui.notifications.warn(\"No actor found. Select a token or set a User Character.\");\n      return;\n    }\n\n    item = actor.items?.get(doc.id) ?? actor.items?.getName(doc.name) ?? doc;\n  }\n\n  if (!actor) {\n    ui.notifications.warn(\"No actor found. Select a token or set a User Character.\");\n    return;\n  }\n  if (!item) {\n    ui.notifications.warn(`No item was provided to Sinless Item Roll. Call with { itemUuid } or { actorUuid, itemId }. Received: ${JSON.stringify(_scope)}`);\n    return;\n  }\n\n  // Session Settings\n  const sessionActor = getSessionSettingsActor();\n  if (!sessionActor) {\n    ui.notifications.error('Actor \"Session Settings\" not found (needed for TN_Global / SkillMeta_JSON).');\n    return;\n  }\n\n  // TN (prefer live value in system.props)\nconst tnRawDirect = sessionActor?.system?.props?.TN_Global;\nconst tnRaw = Number.isFinite(Number(tnRawDirect))\n  ? Number(tnRawDirect)\n  : (() => {\n      const tnPath = findKeyPath(sessionActor.system, \"TN_Global\", \"system\");\n      return tnPath ? num(getByPath(sessionActor, tnPath), 4) : 4;\n    })();\nconst TN = clampTN(tnRaw, 4);\n\n\n  // SkillMeta (optional)\n  const skillMeta = await getSkillMeta(sessionActor);\n\n  // Item-defined roll config\n  const skillKeyRaw = readItemField(item, \"skillKey\");\n  if (!skillKeyRaw) {\n    ui.notifications.error(`Item \"${item.name}\" missing skillKey (e.g., \"Skill_Firearms\").`);\n    return;\n  }\n  const skillKey = String(skillKeyRaw).trim();\n\n  const gearFeature = num(readItemField(item, \"gearFeature\"), 0);\n  const bonusDice = num(readItemField(item, \"bonusDice\"), 0);\n  const diceMod = num(readItemField(item, \"diceMod\"), 0);\n\n  // Pool from item or from SkillMeta (if present)\n  const poolFromItem = readItemField(item, \"poolKey\");\n  const skillInfo = resolveSkillInfo(skillMeta, skillKey);\n  const poolFromMeta = skillInfo?.pool ?? null;\n\n  const poolKeyNorm = normalizePoolKey(poolFromItem ?? poolFromMeta);\n  if (!poolKeyNorm) {\n    ui.notifications.error(`Item \"${item.name}\" missing poolKey and no pool mapping found in SkillMeta_JSON for ${skillKey}.`);\n    return;\n  }\n\n  // Resolve pool current\n  const poolCur = num(readActorProp(actor, poolKeyNorm), 0);\n  // CSB actors store live values under system.props; update path must target that container.\n  const poolPath = actor.system?.props\n    ? `system.props.${poolKeyNorm}`\n    : (findKeyPath(actor.system, poolKeyNorm, \"system\") ?? `system.${poolKeyNorm}`);\n\n  if (poolCur === 0 && readActorProp(actor, poolKeyNorm) === undefined) {\n    ui.notifications.error(`Pool \"${poolKeyNorm}\" not found on actor \"${actor.name}\".`);\n    return;\n  }\n\n  // Resolve skill value from actor (missing keys resolve to 0, but warn)\n  const baseSkillVal = num(readActorProp(actor, skillKey), 0);\n\n  // Group-defaulting / untrained fallback\n  const groupId = skillInfo?.groupId ?? null;\n  const isAsterisked = Boolean(skillInfo?.isAsterisked);\n\n  let mode = \"trained\"; // trained | group | untrainedPool\n  let effectiveSkillVal = baseSkillVal;\n  let chosenGroupSkillKey = null;\n  let chosenGroupSkillVal = null;\n\n  if (baseSkillVal <= 0 && groupId) {\n    const groupSkillKeys = getGroupSkillKeys(skillMeta, groupId);\n    let bestKey = null;\n    let bestVal = 0;\n\n    for (const k of groupSkillKeys) {\n      if (k === skillKey) continue;\n      const v = num(readActorProp(actor, k), 0);\n      if (v > bestVal) { bestVal = v; bestKey = k; }\n    }\n\n    if (bestKey && bestVal > 0) {\n      mode = \"group\";\n      chosenGroupSkillKey = bestKey;\n      chosenGroupSkillVal = bestVal;\n      effectiveSkillVal = Math.max(0, bestVal - 2);\n    }\n  }\n\n  if (baseSkillVal <= 0 && mode !== \"group\") {\n    // No skill and no group skill coverage\n    if (!isAsterisked) {\n      mode = \"untrainedPool\";\n      effectiveSkillVal = 0;\n    } else {\n      ui.notifications.error(`Skill \"${skillKey}\" is trained-only (asterisked) and you have no ranks in it (or any group skill).`);\n      return;\n    }\n  }\n\n  // Limit and spend cap\n  const limit = effectiveSkillVal + gearFeature;\n  const spendCap = (mode === \"untrainedPool\") ? Math.max(0, poolCur) : Math.max(0, Math.min(poolCur, limit));\n\n  // Build dialog header lines\n  const displayLines = [];\n  displayLines.push(`TN ${TN}+`);\n  displayLines.push(`Pool ${poolKeyNorm}: ${poolCur}`);\n  if (mode === \"trained\") {\n    displayLines.push(`Skill ${skillKey}: ${baseSkillVal}`);\n  } else if (mode === \"group\") {\n    displayLines.push(`Skill ${skillKey}: 0 (untrained)`);\n    displayLines.push(`Defaulting via ${chosenGroupSkillKey}: ${chosenGroupSkillVal} → ${effectiveSkillVal} (−2)`);\n  } else {\n    displayLines.push(`Skill ${skillKey}: 0 (untrained)`);\n    displayLines.push(`Untrained fallback: roll full pool; every 4 successes = 1 success`);\n  }\n  displayLines.push(`GearFeature: ${gearFeature}`);\n  displayLines.push(`Limit: ${limit}`);\n  displayLines.push(`Spend cap: ${spendCap}`);\n\n  const allowSpend = (mode !== \"untrainedPool\");\n  const defaultSpend = allowSpend ? spendCap : poolCur;\n\n  const spendHelp = (mode === \"untrainedPool\")\n    ? `Rolling <strong>ALL ${poolCur}</strong> dice from ${poolKeyNorm}. Every <strong>4</strong> successes count as <strong>1</strong> success.`\n    : `Max spend = <strong>${spendCap}</strong> (Limit <strong>${limit}</strong> = EffectiveSkill ${effectiveSkillVal} + Gear ${gearFeature}; Pool ${poolCur})`;\n\n  const runtime = await promptRuntimeInputs({\n    title: item.name,\n    TN,\n    mode,\n    displayLines,\n    spendCap,\n    defaultSpend,\n    spendHelp,\n    allowSpend\n  });\n  if (!runtime) return;\n\n  const sitMod = num(runtime.sit, 0);\n\n  let spend = allowSpend ? num(runtime.spend, 0) : poolCur;\n  if (mode === \"untrainedPool\") spend = poolCur;\n  spend = Math.max(0, Math.min(spend, spendCap));\n\n  const totalDice = Math.max(0, spend + bonusDice + diceMod + sitMod);\n\n  const roll = new Roll(`${totalDice}d6`);\n  await roll.evaluate();\n  const results = roll.dice?.[0]?.results ?? [];\n  const rawSuccesses = results.reduce((acc, r) => acc + (r.result >= TN ? 1 : 0), 0);\n  const finalSuccesses = (mode === \"untrainedPool\") ? Math.floor(rawSuccesses / 4) : rawSuccesses;\n\n  // Pool depletion\n  const newPool = Math.max(0, poolCur - spend);\n  await actor.update({ [poolPath]: newPool });\n\n  const diceHTML = await roll.render();\n\n  const modeLine =\n    (mode === \"trained\") ? \"Trained skill\" :\n    (mode === \"group\") ? `Group defaulting: used ${chosenGroupSkillKey} ${chosenGroupSkillVal} at −2 (effective ${effectiveSkillVal})` :\n    \"Untrained fallback: every 4 successes = 1\";\n\n  const successLine = (mode === \"untrainedPool\")\n    ? `${finalSuccesses} SUCCESS${finalSuccesses === 1 ? \"\" : \"ES\"} <span style=\"font-size:12px;\">(raw ${rawSuccesses} ÷ 4)</span>`\n    : `${finalSuccesses} SUCCESS${finalSuccesses === 1 ? \"\" : \"ES\"}`;\n\n  const content = `\n    <div class=\"sinless-roll\">\n      <h2 style=\"margin:0 0 6px 0;\">${item.name}</h2>\n      <p style=\"margin:0 0 6px 0;\"><strong>Actor:</strong> ${actor.name}</p>\n      <p style=\"margin:0 0 6px 0;\"><strong>TN (Session Settings):</strong> ${TN}+</p>\n      <p style=\"margin:0 0 6px 0;\"><strong>Mode:</strong> ${modeLine}</p>\n      <hr/>\n      <p style=\"margin:0 0 6px 0;\"><strong>Target Skill:</strong> ${skillKey} (base ${baseSkillVal})</p>\n      ${mode === \"group\" ? `<p style=\"margin:0 0 6px 0;\"><strong>Defaulted From:</strong> ${chosenGroupSkillKey} ${chosenGroupSkillVal} → effective ${effectiveSkillVal}</p>` : \"\"}\n      <p style=\"margin:0 0 6px 0;\"><strong>Limit (pool cap):</strong> EffectiveSkill (${effectiveSkillVal}) + GearFeature (${gearFeature}) = <strong>${limit}</strong></p>\n      <p style=\"margin:0 0 6px 0;\"><strong>Pool Spend:</strong> ${spend} (cap ${spendCap})</p>\n      <p style=\"margin:0 0 6px 0;\"><strong>Non-pool dice:</strong> Bonus ${bonusDice} | ItemMod ${diceMod} | Situational ${sitMod}</p>\n      <p style=\"margin:0 0 10px 0;\"><strong>Total Rolled:</strong> <strong>${totalDice}d6</strong></p>\n\n      <div style=\"text-align:center; margin:10px 0 12px 0;\">\n        <div style=\"font-size:28px; font-weight:bold;\">${successLine}</div>\n      </div>\n\n      <p style=\"margin:0 0 10px 0;\"><strong>${poolKeyNorm}:</strong> ${poolCur} → ${newPool}</p>\n\n      <details>\n        <summary>Dice Results</summary>\n        ${diceHTML}\n      </details>\n    </div>\n  `;\n\n  ChatMessage.create({\n    speaker: ChatMessage.getSpeaker({ actor }),\n    content\n  });\n})();",
  "folder": null,
  "flags": {},
  "_stats": {
    "compendiumSource": null,
    "duplicateSource": null,
    "exportSource": {
      "worldId": "sinless",
      "uuid": "Macro.e0B1XInfRgEU3Zcf",
      "coreVersion": "13.351",
      "systemId": "custom-system-builder",
      "systemVersion": "5.0.2"
    },
    "coreVersion": "13.351",
    "systemId": "custom-system-builder",
    "systemVersion": "5.0.2",
    "createdTime": 1767332286485,
    "modifiedTime": 1767403712104,
    "lastModifiedBy": "KoiB8oaGNkPdgzdM"
  },
  "ownership": {
    "default": 0
  }
}